<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AR Med - Pulmão 3D com Chat 3D</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0f172a;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      background: transparent;
    }

    /* Controles flutuantes mínimos */
    .floating-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      display: flex;
      gap: 10px;
    }

    .control-btn {
      padding: 8px 12px;
      background: rgba(30, 41, 59, 0.9);
      color: white;
      border: 1px solid rgba(51, 65, 85, 0.7);
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      backdrop-filter: blur(8px);
    }

    .control-btn:hover {
      background: rgba(51, 65, 85, 0.9);
    }

    /* Input oculto para interação de teclado */
    #hiddenInput {
      position: fixed;
      left: -9999px;
      opacity: 0;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <!-- Controles mínimos -->
  <div class="floating-controls">
    <button id="resetBtn" class="control-btn">Reset</button>
    <button id="toggleChatBtn" class="control-btn">Chat</button>
    <div id="arButtonContainer"></div>
  </div>

  <!-- Input invisível para capturar texto -->
  <input type="text" id="hiddenInput" autocomplete="off">

  <!-- Área 3D -->
  <div id="canvas-container"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // Variáveis globais
    let renderer, scene, camera, controls, group;
    let isARMode = false;
    let lungModel = null;
    let chatPanel = null;
    let chatMessages = [];
    let currentInputText = '';
    let isTyping = false;

    // Sistema de Chat 3D
    class Chat3D {
      constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.messages = [];
        this.maxMessages = 8;
        this.isVisible = true;
        this.width = 4;
        this.height = 3;
        
        this.createChatPanel();
        this.addWelcomeMessage();
        
        scene.add(this.group);
      }

      createChatPanel() {
        // Painel de fundo
        const panelGeometry = new THREE.PlaneGeometry(this.width, this.height);
        const panelMaterial = new THREE.MeshBasicMaterial({
          color: 0x1e293b,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide
        });
        
        this.panel = new THREE.Mesh(panelGeometry, panelMaterial);
        this.group.add(this.panel);

        // Borda do painel
        const borderGeometry = new THREE.EdgesGeometry(panelGeometry);
        const borderMaterial = new THREE.LineBasicMaterial({ 
          color: 0x10b981,
          linewidth: 2
        });
        const border = new THREE.LineSegments(borderGeometry, borderMaterial);
        this.group.add(border);

        // Título
        this.createText("Assistente Pulmonar", 0, this.height/2 - 0.2, 0.15, 0x10b981);
        
        // Área de input
        const inputGeometry = new THREE.PlaneGeometry(this.width - 0.2, 0.3);
        const inputMaterial = new THREE.MeshBasicMaterial({
          color: 0x374151,
          transparent: true,
          opacity: 0.8
        });
        
        this.inputPanel = new THREE.Mesh(inputGeometry, inputMaterial);
        this.inputPanel.position.set(0, -this.height/2 + 0.2, 0.001);
        this.group.add(this.inputPanel);

        // Texto do input
        this.inputText = this.createText("Digite sua pergunta...", 0, -this.height/2 + 0.2, 0.08, 0x9ca3af);

        // Posicionar chat
        this.group.position.set(3, 0, -1);
        this.group.rotation.y = -0.3;
      }

      createText(text, x, y, size, color) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Configurar canvas
        canvas.width = 1024;
        canvas.height = 256;
        
        context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
        context.font = `${size * 400}px Arial`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        
        // Quebrar texto em linhas se necessário
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';
        const maxWidth = canvas.width - 40;
        
        for (const word of words) {
          const testLine = currentLine + (currentLine ? ' ' : '') + word;
          const metrics = context.measureText(testLine);
          
          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }
        if (currentLine) lines.push(currentLine);
        
        // Desenhar linhas
        const lineHeight = size * 400 * 1.2;
        const startY = canvas.height / 2 - (lines.length - 1) * lineHeight / 2;
        
        for (let i = 0; i < lines.length; i++) {
          context.fillText(lines[i], canvas.width / 2, startY + i * lineHeight);
        }
        
        // Criar textura e material
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          alphaTest: 0.1
        });
        
        const geometry = new THREE.PlaneGeometry(2, 0.5);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, 0.002);
        
        this.group.add(mesh);
        return mesh;
      }

      addMessage(text, isUser = false) {
        if (this.messages.length >= this.maxMessages) {
          // Remove mensagem mais antiga
          const oldMessage = this.messages.shift();
          this.group.remove(oldMessage);
        }

        const color = isUser ? 0x10b981 : 0xe5e7eb;
        const yPos = this.height/2 - 0.6 - (this.messages.length * 0.35);
        
        const message = this.createText(
          isUser ? `Você: ${text}` : text, 
          0, 
          yPos, 
          0.08, 
          color
        );
        
        this.messages.push(message);
        this.scrollMessages();
      }

      scrollMessages() {
        // Reposicionar mensagens existentes
        for (let i = 0; i < this.messages.length; i++) {
          const yPos = this.height/2 - 0.6 - (i * 0.35);
          this.messages[i].position.y = yPos;
        }
      }

      updateInputText(text) {
        if (this.inputText) {
          this.group.remove(this.inputText);
        }
        
        const displayText = text || "Digite sua pergunta...";
        const color = text ? 0xffffff : 0x9ca3af;
        
        this.inputText = this.createText(displayText, 0, -this.height/2 + 0.2, 0.08, color);
      }

      async sendMessage(text) {
        if (!text.trim()) return;
        
        this.addMessage(text, true);
        this.updateInputText('');
        
        // Mostrar indicador de digitação
        this.addMessage("Pensando...", false);
        
        try {
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messages: [{ role: 'user', content: text }]
            })
          });

          const data = await response.json();
          
          // Remove indicador de digitação
          if (this.messages.length > 0) {
            const thinkingMessage = this.messages.pop();
            this.group.remove(thinkingMessage);
          }
          
          if (data.answer) {
            this.addMessage(data.answer, false);
            // TTS se disponível
            this.playTTS(data.answer);
          } else {
            this.addMessage('Desculpe, ocorreu um erro.', false);
          }
        } catch (error) {
          console.error('Erro no chat:', error);
          // Remove indicador de digitação
          if (this.messages.length > 0) {
            const thinkingMessage = this.messages.pop();
            this.group.remove(thinkingMessage);
          }
          this.addMessage('Erro de conexão.', false);
        }
      }

      async playTTS(text) {
        try {
          const response = await fetch('/api/voice/tts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text })
          });

          if (response.ok) {
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            await audio.play();
          }
        } catch (error) {
          console.warn('TTS não disponível:', error);
        }
      }

      addWelcomeMessage() {
        this.addMessage("Olá! Sou especialista em pulmão. Como posso ajudar?", false);
      }

      toggle() {
        this.isVisible = !this.isVisible;
        this.group.visible = this.isVisible;
      }

      setPosition(x, y, z) {
        this.group.position.set(x, y, z);
      }

      setRotation(x, y, z) {
        this.group.rotation.set(x, y, z);
      }
    }

    // Inicialização da cena 3D
    function init() {
      const container = document.getElementById('canvas-container');
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      // Cena
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1e293b);

      // Câmera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 3);

      // Grupo para o modelo
      group = new THREE.Group();
      scene.add(group);

      // Luzes
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 0.5);
      scene.add(directionalLight);

      // Controles desktop
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Sistema de chat 3D
      chatPanel = new Chat3D(scene);

      // Carregar modelo do pulmão
      loadLungModel();

      // Botão AR
      setupARButton();

      // Event listeners
      setupEventListeners();
      setupKeyboardInput();
    }

    function loadLungModel() {
      const loader = new GLTFLoader();
      loader.load('/models/lung.glb', (gltf) => {
        lungModel = gltf.scene;
        
        // Centralizar e escalar
        const box = new THREE.Box3().setFromObject(lungModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        lungModel.position.sub(center);
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 2 / maxDim;
        lungModel.scale.setScalar(scale);
        
        group.add(lungModel);
        console.log('Modelo do pulmão carregado');
      }, undefined, (error) => {
        console.error('Erro ao carregar modelo:', error);
        
        // Fallback: criar um placeholder
        const geometry = new THREE.BoxGeometry(1, 1.5, 0.8);
        const material = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
        const placeholder = new THREE.Mesh(geometry, material);
        group.add(placeholder);
      });
    }

    function setupARButton() {
      const arButton = ARButton.createButton(renderer, {
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      });
      
      arButton.textContent = 'Entrar em AR';
      arButton.style.fontSize = '12px';
      arButton.style.padding = '8px 12px';
      
      document.getElementById('arButtonContainer').appendChild(arButton);
    }

    function setupEventListeners() {
      // AR Session events
      renderer.xr.addEventListener('sessionstart', () => {
        console.log('Sessão AR iniciada');
        isARMode = true;
        scene.background = null;
        controls.enabled = false;
        
        // Posicionar elementos para AR
        setTimeout(() => {
          group.position.set(-1.5, 0, -2);
          chatPanel.setPosition(1.5, 0, -2);
          chatPanel.setRotation(0, -0.3, 0);
        }, 1000);
      });

      renderer.xr.addEventListener('sessionend', () => {
        console.log('Sessão AR finalizada');
        isARMode = false;
        scene.background = new THREE.Color(0x1e293b);
        controls.enabled = true;
        
        // Restaurar posições para desktop
        group.position.set(0, 0, 0);
        chatPanel.setPosition(3, 0, -1);
        chatPanel.setRotation(0, -0.3, 0);
      });

      // Botões de controle
      document.getElementById('resetBtn').addEventListener('click', () => {
        if (isARMode) {
          group.position.set(-1.5, 0, -2);
          chatPanel.setPosition(1.5, 0, -2);
        } else {
          camera.position.set(0, 1.6, 3);
          controls.target.set(0, 0, 0);
          controls.update();
        }
      });

      document.getElementById('toggleChatBtn').addEventListener('click', () => {
        chatPanel.toggle();
      });

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Click no chat para focar input
      window.addEventListener('click', (event) => {
        // Verificar se clicou na área do chat
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([chatPanel.panel]);
        
        if (intersects.length > 0) {
          focusInput();
        }
      });
    }

    function setupKeyboardInput() {
      const hiddenInput = document.getElementById('hiddenInput');
      
      hiddenInput.addEventListener('input', (e) => {
        currentInputText = e.target.value;
        chatPanel.updateInputText(currentInputText);
      });

      hiddenInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (currentInputText.trim()) {
            chatPanel.sendMessage(currentInputText);
            currentInputText = '';
            hiddenInput.value = '';
            chatPanel.updateInputText('');
          }
          hiddenInput.blur();
        } else if (e.key === 'Escape') {
          hiddenInput.blur();
          chatPanel.updateInputText('');
        }
      });

      // Atalho de teclado para focar o chat
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Tab' || e.key === '/') {
          e.preventDefault();
          focusInput();
        }
      });
    }

    function focusInput() {
      const hiddenInput = document.getElementById('hiddenInput');
      hiddenInput.focus();
      isTyping = true;
      chatPanel.updateInputText(currentInputText || '');
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render() {
      if (controls && controls.enabled) {
        controls.update();
      }

      // Animação suave do modelo quando não está sendo manipulado
      if (lungModel && !isARMode) {
        lungModel.rotation.y += 0.005;
      }

      renderer.render(scene, camera);
    }

    // Inicialização
    init();
    animate();

  </script>
</body>
</html>