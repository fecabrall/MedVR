<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AR Med - Pulm√£o Interativo</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a0a0a;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      background: transparent;
      position: relative;
    }

    /* Controles flutuantes otimizados */
    .ar-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .ar-btn {
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.8);
      color: #00ff88;
      border: 2px solid rgba(0, 255, 136, 0.3);
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .ar-btn:hover {
      background: rgba(0, 255, 136, 0.1);
      border-color: #00ff88;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
    }

    .ar-btn:active {
      transform: scale(0.95);
    }

    /* Status display */
    .status-display {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.9);
      color: #00ff88;
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid rgba(0, 255, 136, 0.3);
      backdrop-filter: blur(10px);
      font-size: 12px;
      max-width: 200px;
    }

    /* Loading indicator */
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      background: rgba(0, 0, 0, 0.9);
      color: #00ff88;
      padding: 20px 30px;
      border-radius: 10px;
      border: 2px solid #00ff88;
      font-size: 16px;
      text-align: center;
    }

    .spinner {
      width: 30px;
      height: 30px;
      border: 3px solid rgba(0, 255, 136, 0.3);
      border-top: 3px solid #00ff88;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Instru√ß√µes AR */
    .ar-instructions {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(0, 0, 0, 0.9);
      color: #00ff88;
      padding: 15px 25px;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 136, 0.5);
      backdrop-filter: blur(10px);
      text-align: center;
      max-width: 80vw;
      font-size: 14px;
      line-height: 1.4;
    }

    /* Responsivo */
    @media (max-width: 768px) {
      .ar-controls {
        top: 10px;
        left: 10px;
        gap: 8px;
      }
      
      .ar-btn {
        padding: 10px 14px;
        font-size: 12px;
      }
      
      .status-display {
        top: 10px;
        right: 10px;
        font-size: 11px;
        padding: 8px 12px;
      }
      
      .ar-instructions {
        bottom: 10px;
        font-size: 12px;
        padding: 12px 20px;
      }
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <!-- Loading -->
  <div id="loading" class="loading">
    <div class="spinner"></div>
    Carregando AR Pulmonar...
  </div>

  <!-- Controles -->
  <div class="ar-controls">
    <button id="startARBtn" class="ar-btn">üöÄ Iniciar AR</button>
    <button id="resetBtn" class="ar-btn">üîÑ Reset</button>
    <button id="toggleChatBtn" class="ar-btn">üí¨ Chat</button>
    <button id="toggleRotationBtn" class="ar-btn">üîÑ Rota√ß√£o</button>
    <button id="voiceBtn" class="ar-btn">üé§ Voz</button>
  </div>

  <!-- Status -->
  <div class="status-display">
    <div id="status">Sistema Inicializando...</div>
  </div>

  <!-- Instru√ß√µes -->
  <div class="ar-instructions" id="instructions">
    üì± Permita acesso √† c√¢mera e mova o dispositivo para encontrar uma superf√≠cie plana
  </div>

  <!-- Canvas AR -->
  <div id="canvas-container"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // Vari√°veis globais
    let renderer, scene, camera, controls;
    let lungModel, chatSystem, voiceSystem;
    let isARActive = false;
    let autoRotate = true;
    let hitTestSource = null;
    let reticle;

    // Sistema de Chat 3D Melhorado
    class Chat3D {
      constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.messages = [];
        this.maxMessages = 6;
        this.isVisible = true;
        this.isTyping = false;
        
        this.createPanel();
        this.addWelcomeMessage();
        this.setupVoiceRecognition();
        
        scene.add(this.group);
        this.positionForAR();
      }

      createPanel() {
        // Painel principal com efeito hologr√°fico
        const panelGeo = new THREE.PlaneGeometry(2.5, 3);
        const panelMat = new THREE.MeshBasicMaterial({
          color: 0x001122,
          transparent: true,
          opacity: 0.85,
          side: THREE.DoubleSide
        });
        
        this.panel = new THREE.Mesh(panelGeo, panelMat);
        this.group.add(this.panel);

        // Borda hologr√°fica
        const borderGeo = new THREE.EdgesGeometry(panelGeo);
        const borderMat = new THREE.LineBasicMaterial({ 
          color: 0x00ff88,
          linewidth: 3
        });
        const border = new THREE.LineSegments(borderGeo, borderMat);
        this.group.add(border);

        // T√≠tulo
        this.createText("ü´Å ASSISTENTE PULMONAR", 0, 1.3, 0.12, 0x00ff88, true);
        
        // √Årea de mensagens
        this.messageArea = new THREE.Group();
        this.group.add(this.messageArea);

        // Indicador de digita√ß√£o
        this.typingIndicator = this.createTypingIndicator();
        this.group.add(this.typingIndicator);
      }

      createText(text, x, y, size, color, isBold = false) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        canvas.width = 1024;
        canvas.height = 128;
        
        context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
        context.font = `${isBold ? 'bold ' : ''}${size * 300}px Arial`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        
        // Quebrar texto
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';
        const maxWidth = canvas.width - 40;
        
        for (const word of words) {
          const testLine = currentLine + (currentLine ? ' ' : '') + word;
          const metrics = context.measureText(testLine);
          
          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }
        if (currentLine) lines.push(currentLine);
        
        // Desenhar com efeito glow
        context.shadowColor = `#${color.toString(16).padStart(6, '0')}`;
        context.shadowBlur = 5;
        
        const lineHeight = size * 300 * 1.2;
        const startY = canvas.height / 2 - (lines.length - 1) * lineHeight / 2;
        
        for (let i = 0; i < lines.length; i++) {
          context.fillText(lines[i], canvas.width / 2, startY + i * lineHeight);
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          alphaTest: 0.1
        });
        
        const geometry = new THREE.PlaneGeometry(2.2, 0.3);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, 0.01);
        
        this.group.add(mesh);
        return mesh;
      }

      createTypingIndicator() {
        const group = new THREE.Group();
        
        // Tr√™s pontos animados
        for (let i = 0; i < 3; i++) {
          const dot = new THREE.Mesh(
            new THREE.SphereGeometry(0.02),
            new THREE.MeshBasicMaterial({ color: 0x00ff88 })
          );
          dot.position.set(-0.05 + i * 0.05, -1.2, 0.02);
          dot.userData = { delay: i * 200 };
          group.add(dot);
        }
        
        group.visible = false;
        return group;
      }

      addMessage(text, isUser = false) {
        if (this.messages.length >= this.maxMessages) {
          const oldMessage = this.messages.shift();
          this.messageArea.remove(oldMessage);
        }

        const prefix = isUser ? "üë§" : "ü§ñ";
        const color = isUser ? 0x0088ff : 0x00ff88;
        const yPos = 0.8 - (this.messages.length * 0.25);
        
        const message = this.createText(
          `${prefix} ${text}`, 
          0, 
          yPos, 
          0.08, 
          color
        );
        
        this.messageArea.add(message);
        this.messages.push(message);
      }

      async sendMessage(text) {
        if (!text.trim()) return;
        
        this.addMessage(text, true);
        this.showTyping(true);
        
        try {
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messages: [{ role: 'user', content: text }]
            })
          });

          const data = await response.json();
          this.showTyping(false);
          
          if (data.answer) {
            this.addMessage(data.answer, false);
            this.speakText(data.answer);
          } else {
            this.addMessage('Erro na comunica√ß√£o', false);
          }
        } catch (error) {
          console.error('Erro no chat:', error);
          this.showTyping(false);
          this.addMessage('Erro de conex√£o', false);
        }
      }

      showTyping(show) {
        this.typingIndicator.visible = show;
        this.isTyping = show;
      }

      addWelcomeMessage() {
        this.addMessage("Ol√°! Sou seu assistente especializado em pulm√£o. Como posso ajudar?", false);
      }

      positionForAR() {
        this.group.position.set(1.5, 0, -1);
        this.group.rotation.y = -0.3;
      }

      toggle() {
        this.isVisible = !this.isVisible;
        this.group.visible = this.isVisible;
      }

      async speakText(text) {
        try {
          const response = await fetch('/api/voice/tts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text })
          });

          if (response.ok) {
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            await audio.play();
          }
        } catch (error) {
          console.warn('TTS n√£o dispon√≠vel:', error);
        }
      }

      setupVoiceRecognition() {
        if ('webkitSpeechRecognition' in window) {
          this.recognition = new webkitSpeechRecognition();
          this.recognition.continuous = false;
          this.recognition.interimResults = false;
          this.recognition.lang = 'pt-BR';
          
          this.recognition.onresult = (event) => {
            const result = event.results[0][0].transcript;
            this.sendMessage(result);
          };
          
          this.recognition.onerror = (event) => {
            console.error('Erro no reconhecimento de voz:', event.error);
          };
        }
      }

      startVoiceRecognition() {
        if (this.recognition) {
          this.recognition.start();
        }
      }

      update() {
        // Animar indicador de digita√ß√£o
        if (this.isTyping) {
          const time = Date.now() * 0.003;
          this.typingIndicator.children.forEach((dot, i) => {
            dot.position.y = -1.2 + Math.sin(time + dot.userData.delay * 0.001) * 0.05;
          });
        }
        
        // Efeito hologr√°fico na borda
        const border = this.group.children[1];
        if (border) {
          border.material.color.setHSL(0.45 + Math.sin(Date.now() * 0.002) * 0.1, 1, 0.5);
        }
      }
    }

    // Sistema de Voz
    class VoiceSystem {
      constructor() {
        this.isRecording = false;
        this.mediaRecorder = null;
        this.chunks = [];
      }

      async startRecording() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.mediaRecorder = new MediaRecorder(stream);
          this.chunks = [];
          
          this.mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) this.chunks.push(e.data);
          };
          
          this.mediaRecorder.onstop = () => {
            this.processRecording();
          };
          
          this.mediaRecorder.start();
          this.isRecording = true;
          updateStatus('üé§ Gravando...');
          
        } catch (error) {
          console.error('Erro ao acessar microfone:', error);
          updateStatus('‚ùå Erro no microfone');
        }
      }

      stopRecording() {
        if (this.mediaRecorder && this.isRecording) {
          this.mediaRecorder.stop();
          this.isRecording = false;
          updateStatus('üîÑ Processando √°udio...');
        }
      }

      async processRecording() {
        const blob = new Blob(this.chunks, { type: 'audio/webm' });
        const formData = new FormData();
        formData.append('file', blob, 'recording.webm');

        try {
          const response = await fetch('/api/voice/chat', {
            method: 'POST',
            body: formData
          });

          const data = await response.json();
          
          if (data.transcript && chatSystem) {
            chatSystem.addMessage(data.transcript, true);
            if (data.reply) {
              chatSystem.addMessage(data.reply, false);
            }
          }
          
          updateStatus('‚úÖ Processado');
        } catch (error) {
          console.error('Erro no processamento:', error);
          updateStatus('‚ùå Erro no processamento');
        }
      }
    }

    // Fun√ß√£o para criar modelo de pulm√£o melhorado
    function createLungModel() {
      const group = new THREE.Group();
      
      // Geometria b√°sica do pulm√£o
      const lungGeo = new THREE.SphereGeometry(0.15, 32, 16);
      lungGeo.scale(1, 1.2, 0.8);
      
      // Material com shader personalizado
      const lungMat = new THREE.MeshPhongMaterial({
        color: 0xff6b6b,
        transparent: true,
        opacity: 0.8,
        shininess: 30
      });
      
      // Pulm√£o direito
      const rightLung = new THREE.Mesh(lungGeo, lungMat);
      rightLung.position.set(0.1, 0, 0);
      group.add(rightLung);
      
      // Pulm√£o esquerdo
      const leftLung = new THREE.Mesh(lungGeo, lungMat);
      leftLung.position.set(-0.1, 0, 0);
      leftLung.scale.set(0.9, 1, 1);
      group.add(leftLung);
      
      // Traqueia
      const tracheaGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.3);
      const tracheaMat = new THREE.MeshPhongMaterial({ color: 0xffaa77 });
      const trachea = new THREE.Mesh(tracheaGeo, tracheaMat);
      trachea.position.set(0, 0.25, 0);
      group.add(trachea);
      
      // Br√¥nquios
      const bronchiGeo = new THREE.CylinderGeometry(0.015, 0.01, 0.15);
      const bronchiMat = new THREE.MeshPhongMaterial({ color: 0xffcc88 });
      
      const rightBronchi = new THREE.Mesh(bronchiGeo, bronchiMat);
      rightBronchi.position.set(0.08, 0.1, 0);
      rightBronchi.rotation.z = -0.3;
      group.add(rightBronchi);
      
      const leftBronchi = new THREE.Mesh(bronchiGeo, bronchiMat);
      leftBronchi.position.set(-0.08, 0.1, 0);
      leftBronchi.rotation.z = 0.3;
      group.add(leftBronchi);
      
      // Part√≠culas para efeito de respira√ß√£o
      const particleGeo = new THREE.BufferGeometry();
      const particleCount = 100;
      const positions = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 0.5;
        positions[i + 1] = (Math.random() - 0.5) * 0.5;
        positions[i + 2] = (Math.random() - 0.5) * 0.5;
      }
      
      particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const particleMat = new THREE.PointsMaterial({
        color: 0x88ccff,
        size: 0.01,
        transparent: true,
        opacity: 0.6
      });
      
      const particles = new THREE.Points(particleGeo, particleMat);
      group.add(particles);
      
      // Adicionar anima√ß√£o de respira√ß√£o
      group.userData = {
        breathePhase: 0,
        particles: particles,
        lungs: [rightLung, leftLung]
      };
      
      return group;
    }

    // Fun√ß√£o para atualizar status
    function updateStatus(message) {
      document.getElementById('status').textContent = message;
    }

    // Fun√ß√£o para atualizar instru√ß√µes
    function updateInstructions(message) {
      document.getElementById('instructions').textContent = message;
    }

    // Inicializa√ß√£o da aplica√ß√£o
    async function init() {
      updateStatus('üîÑ Inicializando...');
      
      const container = document.getElementById('canvas-container');
      
      // Renderer otimizado para AR
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        precision: 'highp',
        powerPreference: 'high-performance'
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x000000, 0);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      
      container.appendChild(renderer.domElement);

      // Cena
      scene = new THREE.Scene();

      // C√¢mera
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
      camera.position.set(0, 1.6, 0.3);

      // Controles desktop
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 0, 0);

      // Ilumina√ß√£o otimizada
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 0.5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Criar modelo do pulm√£o
      lungModel = createLungModel();
      scene.add(lungModel);

      // Sistema de chat 3D
      chatSystem = new Chat3D(scene);

      // Sistema de voz
      voiceSystem = new VoiceSystem();

      // Reticle para AR
      const reticleGeo = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
      const reticleMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ff88, 
        transparent: true, 
        opacity: 0.7 
      });
      reticle = new THREE.Mesh(reticleGeo, reticleMat);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Setup AR
      setupAR();
      setupEventListeners();

      updateStatus('‚úÖ Sistema Pronto');
      updateInstructions('üéØ Clique em "Iniciar AR" para come√ßar');
      
      // Ocultar loading
      document.getElementById('loading').style.display = 'none';
    }

    function setupAR() {
      // Configurar WebXR AR
      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          if (supported) {
            updateStatus('üì± AR Suportado');
          } else {
            updateStatus('‚ùå AR n√£o suportado');
          }
        });
      }
    }

    function setupEventListeners() {
      // Bot√£o AR
      document.getElementById('startARBtn').addEventListener('click', async () => {
        if (navigator.xr) {
          try {
            const session = await navigator.xr.requestSession('immersive-ar', {
              requiredFeatures: ['hit-test'],
              optionalFeatures: ['dom-overlay'],
              domOverlay: { root: document.body }
            });
            
            renderer.xr.setSession(session);
            isARActive = true;
            updateStatus('üöÄ AR Ativo');
            updateInstructions('üéØ Mire a c√¢mera em uma superf√≠cie plana');
            
            // Configurar hit testing
            session.requestReferenceSpace('viewer').then((referenceSpace) => {
              session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                hitTestSource = source;
              });
            });
            
            session.addEventListener('end', () => {
              isARActive = false;
              hitTestSource = null;
              updateStatus('üì± AR Finalizado');
              updateInstructions('üéØ Clique em "Iniciar AR" para come√ßar');
              scene.background = new THREE.Color(0x0a0a0a);
              controls.enabled = true;
            });
            
            scene.background = null;
            controls.enabled = false;
            
          } catch (error) {
            console.error('Erro ao iniciar AR:', error);
            updateStatus('‚ùå Erro no AR');
          }
        } else {
          updateStatus('‚ùå WebXR n√£o suportado');
        }
      });

      // Reset
      document.getElementById('resetBtn').addEventListener('click', () => {
        if (isARActive) {
          lungModel.position.set(0, 0, -1);
          chatSystem.group.position.set(1.5, 0, -1);
        } else {
          camera.position.set(0, 1.6, 0.3);
          controls.target.set(0, 0, 0);
          controls.update();
        }
        updateStatus('üîÑ Reset realizado');
      });

      // Toggle Chat
      document.getElementById('toggleChatBtn').addEventListener('click', () => {
        chatSystem.toggle();
        updateStatus(chatSystem.isVisible ? 'üí¨ Chat ativado' : 'üí¨ Chat desativado');
      });

      // Toggle Rota√ß√£o
      document.getElementById('toggleRotationBtn').addEventListener('click', () => {
        autoRotate = !autoRotate;
        updateStatus(autoRotate ? 'üîÑ Rota√ß√£o ativada' : '‚è∏Ô∏è Rota√ß√£o pausada');
      });

      // Voz
      document.getElementById('voiceBtn').addEventListener('click', () => {
        if (voiceSystem.isRecording) {
          voiceSystem.stopRecording();
          document.getElementById('voiceBtn').textContent = 'üé§ Voz';
        } else {
          voiceSystem.startRecording();
          document.getElementById('voiceBtn').textContent = '‚èπÔ∏è Parar';
        }
      });

      // Resize
      window.addEventListener('resize', onWindowResize);

      // Touch para intera√ß√£o
      setupTouchInteraction();
    }

    function setupTouchInteraction() {
      const canvas = renderer.domElement;
      let isDragging = false;
      let previousTouch = null;

      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDragging = true;
        previousTouch = e.touches[0];
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (isDragging && isARActive && e.touches.length === 1) {
          const touch = e.touches[0];
          const deltaX = touch.clientX - previousTouch.clientX;
          const deltaY = touch.clientY - previousTouch.clientY;
          
          // Mover modelo
          lungModel.position.x += deltaX * 0.001;
          lungModel.position.y -= deltaY * 0.001;
          
          previousTouch = touch;
        }
      }, { passive: false });

      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        isDragging = false;
        
        // Double tap para chat por voz
        if (e.changedTouches.length === 1) {
          const now = Date.now();
          if (this.lastTap && (now - this.lastTap) < 300) {
            chatSystem.startVoiceRecognition();
            updateStatus('üé§ Ouvindo...');
          }
          this.lastTap = now;
        }
      }, { passive: false });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render() {
      const time = Date.now() * 0.001;
      
      // Atualizar controles desktop
      if (controls.enabled) {
        controls.update();
      }

      // Anima√ß√£o do pulm√£o
      if (lungModel) {
        // Rota√ß√£o autom√°tica
        if (autoRotate) {
          lungModel.rotation.y += 0.008;
          lungModel.rotation.x = Math.sin(time * 0.5) * 0.1;
        }
        
        // Efeito de respira√ß√£o
        const breathScale = 1 + Math.sin(time * 2) * 0.05;
        lungModel.userData.lungs?.forEach(lung => {
          lung.scale.set(breathScale, breathScale, breathScale);
        });
        
        // Animar part√≠culas
        if (lungModel.userData.particles) {
          const positions = lungModel.userData.particles.geometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            positions[i + 1] += Math.sin(time * 3 + i) * 0.001;
          }
          lungModel.userData.particles.geometry.attributes.position.needsUpdate = true;
        }
      }

      // Atualizar chat 3D
      if (chatSystem) {
        chatSystem.update();
      }

      // Hit testing AR
      if (renderer.xr.isPresenting && hitTestSource) {
        const frame = renderer.xr.getFrame();
        const hitTestResults = frame.getHitTestResults(hitTestSource);

        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          reticle.visible = true;
          reticle.matrix.fromArray(hit.getPose(renderer.xr.getReferenceSpace()).transform.matrix);
          
          updateInstructions('üéØ Toque para posicionar o pulm√£o');
        } else {
          reticle.visible = false;
          updateInstructions('üì± Procure uma superf√≠cie plana');
        }
      }

      renderer.render(scene, camera);
    }

    // Adicionar funcionalidade de toque no AR para posicionar modelo
    function setupARTouchPlacement() {
      renderer.domElement.addEventListener('click', (event) => {
        if (renderer.xr.isPresenting && reticle.visible) {
          // Posicionar modelo na posi√ß√£o do reticle
          lungModel.position.setFromMatrixPosition(reticle.matrix);
          lungModel.visible = true;
          
          // Posicionar chat pr√≥ximo
          chatSystem.group.position.set(
            lungModel.position.x + 1,
            lungModel.position.y,
            lungModel.position.z - 0.5
          );
          
          updateStatus('‚úÖ Modelo posicionado');
          updateInstructions('ü´Å Use gestos para interagir com o pulm√£o');
        }
      });
    }

    // Comandos de voz personalizados
    function setupVoiceCommands() {
      if ('webkitSpeechRecognition' in window) {
        const recognition = new webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = false;
        recognition.lang = 'pt-BR';
        
        const commands = {
          'girar': () => {
            autoRotate = !autoRotate;
            updateStatus(`üîÑ Rota√ß√£o ${autoRotate ? 'ativada' : 'desativada'}`);
          },
          'chat': () => {
            chatSystem.toggle();
            updateStatus(`üí¨ Chat ${chatSystem.isVisible ? 'ativado' : 'desativado'}`);
          },
          'reset': () => {
            document.getElementById('resetBtn').click();
          },
          'parar rota√ß√£o': () => {
            autoRotate = false;
            updateStatus('‚è∏Ô∏è Rota√ß√£o pausada');
          },
          'come√ßar rota√ß√£o': () => {
            autoRotate = true;
            updateStatus('üîÑ Rota√ß√£o ativada');
          }
        };
        
        recognition.onresult = (event) => {
          const result = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
          
          if (commands[result]) {
            commands[result]();
          } else {
            // Enviar para o chat se n√£o for comando
            chatSystem.sendMessage(result);
          }
        };
        
        // Ativar reconhecimento cont√≠nuo em AR
        renderer.xr.addEventListener('sessionstart', () => {
          recognition.start();
        });
        
        renderer.xr.addEventListener('sessionend', () => {
          recognition.stop();
        });
      }
    }

    // Efeitos visuais avan√ßados
    function addVisualEffects() {
      // Efeito de halo ao redor do pulm√£o
      const haloGeo = new THREE.RingGeometry(0.3, 0.35, 32);
      const haloMat = new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      const halo = new THREE.Mesh(haloGeo, haloMat);
      halo.rotation.x = -Math.PI / 2;
      lungModel.add(halo);
      
      // Animar halo
      setInterval(() => {
        halo.rotation.z += 0.01;
        halo.material.opacity = 0.2 + Math.sin(Date.now() * 0.003) * 0.1;
      }, 16);
    }

    // Inicializar aplica√ß√£o
    init().then(() => {
      setupARTouchPlacement();
      setupVoiceCommands();
      addVisualEffects();
      animate();
      
      updateStatus('üöÄ AR Pulmonar Ready!');
      updateInstructions('üéØ Toque em "Iniciar AR" para come√ßar a experi√™ncia imersiva');
    });

  </script>
</body>
</html>